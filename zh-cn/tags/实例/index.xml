<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>实例 on 郭超超的博客</title>
    <link>https://blog.adminchao.com/zh-cn/tags/%E5%AE%9E%E4%BE%8B/</link>
    <description>Recent content in 实例 on 郭超超的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 10 Jan 2019 15:29:08 +0000</lastBuildDate><atom:link href="https://blog.adminchao.com/zh-cn/tags/%E5%AE%9E%E4%BE%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Laravel Eloquent 返回结果优化</title>
      <link>https://blog.adminchao.com/zh-cn/posts/laravel-eloquent-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E4%BC%98%E5%8C%96/</link>
      <pubDate>Thu, 10 Jan 2019 15:29:08 +0000</pubDate>
      
      <guid>https://blog.adminchao.com/zh-cn/posts/laravel-eloquent-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E4%BC%98%E5%8C%96/</guid>
      <description>前言 我们都知道在模型中使用 appends 属性来构建访问器使得返回结果添加一些字段信息，但是这样的话有一个坏处，就是所有这个模型的返回结果都会有这些字段信息，如果接口中规定了严格的返回信息字段，这样就不合适了。
能不能有好的方法动态的显示或隐藏这些字段信息呢？
答案是肯定的。
动态显示 在接口中临时显示 首先在 Model 中构建访问器 1 2 3  public function getUsernameAttribute(){ return $this-&amp;gt;hasOne(&amp;#39;App\User&amp;#39;,&amp;#39;id&amp;#39;,&amp;#39;user_id&amp;#39;)-&amp;gt;value(&amp;#39;username&amp;#39;); }   Model 不建立 appends 属性 单条记录 1 2 3 4 5  public function getUserInfo(Request $request){ $id = $request-&amp;gt;get(&amp;#39;id&amp;#39;,null); $result = User::find($id)-&amp;gt;append(&amp;#39;username&amp;#39;); return response()-&amp;gt;json($result); }   多条记录 1 2 3 4 5 6 7 8 9 10  public function getUsers(Request $request){ $limit = $request-&amp;gt;get(&amp;#39;limit&amp;#39;,10); $results = User::orderBy(&amp;#39;id&amp;#39;,&amp;#39;desc&amp;#39;) -&amp;gt;paginate($limit) -&amp;gt;transform(function($item,$key){ $item-&amp;gt;append(&amp;#39;username&amp;#39;); return $item; //如果不 return 出去返回的是 null  }); return response()-&amp;gt;json($results); }   如果不想用 append 方法的关联关系可以这样用 或者报 Method items does not exist.</description>
    </item>
    
    <item>
      <title>Laravel overtrue/wechat 微信用法</title>
      <link>https://blog.adminchao.com/zh-cn/posts/laravel-overtrue-wechat-%E5%BE%AE%E4%BF%A1%E7%94%A8%E6%B3%95/</link>
      <pubDate>Fri, 08 Jun 2018 12:51:35 +0000</pubDate>
      
      <guid>https://blog.adminchao.com/zh-cn/posts/laravel-overtrue-wechat-%E5%BE%AE%E4%BF%A1%E7%94%A8%E6%B3%95/</guid>
      <description>网页授权登陆中间件 创建 app/Http/Middleware/WechatAuth.php 中间件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  public function handle($request, Closure $next, $account = &amp;#39;default&amp;#39;, $scopes = null) { // $account 与 $scopes 写反的情况  if (is_array($scopes) || (\is_string($account) &amp;amp;&amp;amp; str_is(&amp;#39;snsapi_*&amp;#39;, $account))) { list($account, $scopes) = [$scopes, $account]; $account || $account = &amp;#39;default&amp;#39;; } $isNewSession = false; $sessionKey = \sprintf(&amp;#39;user_id&amp;#39;, $account); $config = config(\sprintf(&amp;#39;wechat.</description>
    </item>
    
    <item>
      <title>Laravel Eloquent 括号查询</title>
      <link>https://blog.adminchao.com/zh-cn/posts/laravel-eloquent-%E6%8B%AC%E5%8F%B7%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Fri, 08 Jun 2018 12:36:54 +0000</pubDate>
      
      <guid>https://blog.adminchao.com/zh-cn/posts/laravel-eloquent-%E6%8B%AC%E5%8F%B7%E6%9F%A5%E8%AF%A2/</guid>
      <description>相当于 select * from queue_second_sold where status=0 and (buy_user_id = 341 or (sell_user_id = 341 and buy_user_id != 0)) order by id desc,用法如下:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  /** * 交易大厅-定向交易 * @param Request $request * @return \Illuminate\Http\JsonResponse */ public function soldList(Request $request){ $type = $request-&amp;gt;get(&amp;#39;type&amp;#39;,0); //交易大厅  $limit = $request-&amp;gt;get(&amp;#39;limit&amp;#39;,10); $user = User::getUserInfo(); if($type == 1){ //定向交易  $results = QueueSecondSold::where(&amp;#39;status&amp;#39;,0) -&amp;gt;where(function($query) use ($user){ $query-&amp;gt;where(&amp;#39;sell_user_id&amp;#39;,$user-&amp;gt;id) -&amp;gt;where(&amp;#39;buy_user_id&amp;#39;,&amp;#39;!</description>
    </item>
    
    <item>
      <title>Laravel Paginate 分页</title>
      <link>https://blog.adminchao.com/zh-cn/posts/laravel-paginate-%E5%88%86%E9%A1%B5/</link>
      <pubDate>Fri, 08 Jun 2018 11:56:23 +0000</pubDate>
      
      <guid>https://blog.adminchao.com/zh-cn/posts/laravel-paginate-%E5%88%86%E9%A1%B5/</guid>
      <description>前言 使用 Laravel Eloquent 的 paginate 方法会很容易对数据进行分页。非常好用！我太喜欢了。
使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //paginate 源码 public function paginate($perPage = 15, $columns = [&amp;#39;*&amp;#39;], $pageName = &amp;#39;page&amp;#39;, $page = null) { $page = $page ?: Paginator::resolveCurrentPage($pageName); $total = $this-&amp;gt;getCountForPagination($columns); $results = $total ? $this-&amp;gt;forPage($page, $perPage)-&amp;gt;get($columns) : collect(); return $this-&amp;gt;paginator($results, $total, $perPage, $page, [ &amp;#39;path&amp;#39; =&amp;gt; Paginator::resolveCurrentPath(), &amp;#39;pageName&amp;#39; =&amp;gt; $pageName, ]); } public function showApi(Request $request) { $limit = $request-&amp;gt;get(&amp;#39;limit&amp;#39;); //$page = $request-&amp;gt;get(&amp;#39;page&amp;#39;);  $results = Seller::paginate($limit); //无须接收 $page ,laravel 自动接收  //$results = Seller::forPage($page,$limit)-&amp;gt;get(); 或者用这种  //$results = Seller::paginate($limit,[&amp;#39;*&amp;#39;],&amp;#39;page&amp;#39;,5); //paginate 控制page  return response()-&amp;gt;json([&amp;#39;code&amp;#39; =&amp;gt; 0, &amp;#39;data&amp;#39; =&amp;gt; $results-&amp;gt;items(), &amp;#39;count&amp;#39; =&amp;gt; $results-&amp;gt;total()]); }   </description>
    </item>
    
    <item>
      <title>Laravel 全局作用域</title>
      <link>https://blog.adminchao.com/zh-cn/posts/laravel-%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Fri, 08 Jun 2018 11:41:08 +0000</pubDate>
      
      <guid>https://blog.adminchao.com/zh-cn/posts/laravel-%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>前言 全局作用域是用来全局添加执行约束的，添加过后涉及到的模型操作全部添加此约束。如：原 select * from user 添加过后变为 select * from user where is_delete = 0
用法 建立 App/Scopes/SiteScope.php ： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  &amp;lt;?php namespace App\Scopes; use App\Site; use Illuminate\Database\Eloquent\ScopeInterface; use Illuminate\Database\Eloquent\Model; use Illuminate\Database\Eloquent\Builder; class SiteScope implements ScopeInterface{ public function apply(Builder $builder, Model $model) { $site = Site::getSiteId(); return $builder-&amp;gt;where(&amp;#39;site_id&amp;#39;, $site); } public function remove(Builder $builder, Model $model) //必须有remove  { $column = $model-&amp;gt;getQualifiedDeletedAtColumn(); $query = $builder-&amp;gt;getQuery(); foreach ((array) $query-&amp;gt;wheres as $key =&amp;gt; $where) { // If the where clause is a soft delete date constraint, we will remove it from  // the query and reset the keys on the wheres.</description>
    </item>
    
    <item>
      <title>Laravel 生成测试数据</title>
      <link>https://blog.adminchao.com/zh-cn/posts/laravel-%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Thu, 08 Mar 2018 11:14:46 +0000</pubDate>
      
      <guid>https://blog.adminchao.com/zh-cn/posts/laravel-%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE/</guid>
      <description>前言 使用 Laravel Faker 生成测试数据，很方便测试调试。
用法 打开 app/database/factories/ModelFactory.php 编辑如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  $factory-&amp;gt;define(App\User::class, function (Faker\Generator $faker) { $faker = Faker\Factory::create(&amp;#39;zh_CN&amp;#39;); //中文包  return [ &amp;#39;openid&amp;#39; =&amp;gt; str_random(10), &amp;#39;nickname&amp;#39; =&amp;gt; $faker-&amp;gt;name, //中文姓名  &amp;#39;mobile&amp;#39; =&amp;gt; $faker-&amp;gt;phoneNumber, &amp;#39;avatar&amp;#39; =&amp;gt; $faker-&amp;gt;imageUrl(), //图片URL地址  &amp;#39;integral&amp;#39; =&amp;gt; $faker-&amp;gt;randomNumber(3), //随机3位整型(0-999)  &amp;#39;balance&amp;#39; =&amp;gt; $faker-&amp;gt;randomFloat(2, 0, 10000), //随机浮点数,2位小数点,最小0，最大10000  &amp;#39;birthday&amp;#39; =&amp;gt; $faker-&amp;gt;date(), //日期  &amp;#39;created_time&amp;#39; =&amp;gt; $faker-&amp;gt;unixTime(), //unix时间戳  &amp;#39;password&amp;#39; =&amp;gt; App\User::generatePassword(&amp;#39;haha123&amp;#39;), //可用模型方法生成数据  ]; }); $factory-&amp;gt;define(App\Product::class, function (Faker\Generator $faker) { $faker = Faker\Factory::create(&amp;#39;zh_CN&amp;#39;); //用模型生成要关联随机的数组  $seller = App\Seller::where(&amp;#39;status&amp;#39;, 1)-&amp;gt;get()-&amp;gt;toArray(); foreach ($seller as $value) { $row[] = $value[&amp;#39;id&amp;#39;]; } return [ &amp;#39;product_no&amp;#39; =&amp;gt; $faker-&amp;gt;randomNumber(8), &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;【测试商品】&amp;#39; .</description>
    </item>
    
    <item>
      <title>Thinkphp5 创建 API 实例教程</title>
      <link>https://blog.adminchao.com/zh-cn/posts/thinkphp5-%E5%88%9B%E5%BB%BA-api-%E5%AE%9E%E4%BE%8B%E6%95%99%E7%A8%8B/</link>
      <pubDate>Fri, 04 Aug 2017 20:20:03 +0000</pubDate>
      
      <guid>https://blog.adminchao.com/zh-cn/posts/thinkphp5-%E5%88%9B%E5%BB%BA-api-%E5%AE%9E%E4%BE%8B%E6%95%99%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;现在的开发模式前后端分离已经成了主流，需要用到 API 接口的开发，下面使用 Thinkphp5 开发 API 接口，主要是路由的定制。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
